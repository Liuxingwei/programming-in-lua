\chapter{类型和值}

Lua 是动态类型语言。其中没有类型定义，每个值持有自己的类型。

Lua 中有 8 种基本类型： \verb|nil, boolean, number, string, userdata, function, thread, table|。\verb|type| 函数用于获取给定的值的类型名：
\begin{verbatim}
        print(type("Hello world"))              --> string
        print(type(10.4*3))                     --> number
        print(type(print))                      --> function
        print(type(type))                       --> type
        print(type(true))                       --> boolean
        print(type(nil))                        --> nil
        print(type(type(X)))                    --> string
\end{verbatim}
最后一行无论 \verb|X| 的值是什么，结果都是 ``string''，因为 \verb|type| 的值总是字符串。

变量没有预定义类型，每个变量可以包含任意类型的值：
\begin{verbatim}
        print(type(a))                          --> nil (`a' 没有初始化)
        a = 10
        print(type(a))                          --> number
        a = "a string!"
        print(type(a))                          --> string
        a = print                               --> 你没看错，这是正确的！
        print(type(a))                          --> function
\end{verbatim}
注意最后两行：在 Lua 中，函数是一等值；所以我们能够像操作其它值一样操作它。（第六章将看到关于这一特性的更多详情。）

通常，将同一变量用于不同类型，会造成混乱。但是，有时候，审慎地使用这一特性很有用，比如使用 nil 来区别正常的返回值和非正常情况。

\section{Nil}

Nil 是一个只带有 \verb|nil| 一个值的类型（单值类型），它的主要作用是区别其他类型。Lua 使用 nil 作为无效值，表示没有有用的有效值。就像我们看到的那样，全局变量被赋值前的默认值就是 nil，还可以用给全局变量赋 nil 值的方式来删除之。

\section{Booleans}

布尔类型有两个值：\verb|false| 和 \verb|true|，用来表示布尔值。但是条件值并未由布尔值独霸：在 Lua 中任何值都能用于条件。条件判断（比如控制结构中的条件）将 \verb|false| 和 \verb|nil| 视为假，其余值均被视为真。尤其要注意的是，在条件判断中Lua 将 0 和空字符串也视为真。

在本书中，我用“假”来表示任务假值，包括布尔值 \verb|false| 和 \verb|nil|。当特指布尔值时，我用“\verb|false|”。同样的规则可以推广到“真”和“\verb|true|”。

\section{Numbers}

数字类型表示实数（双精度浮点数）。Lua 没有整型。

有些人担心使用浮点数，即使简单的处境和比较也可能会产生怪异的结果。事实并非如此。实际上如今所有平台都遵循 IEEE 754 标准中的表示法。遵循这一标准，仅当数字不能精确表示时，才会出现误差。结果不能精确表示时，才会出现舍入。能够精确表示的结果必须给出精确值。

$2^{53}$（约等于$10^{16}$）以内的整数都能用双精度浮点数精确表示。当使用双精度数表示整数时，不会出现舍入错误，除非其绝对值超出了$2^{53}$。Lua 数字能够表示任何 32 位整数而不出现舍入问题。

当然，分数会遇到表示错误。这种情况和使用纸笔没什么区别。如果我们用十进制计算 $1/7$，我们将不得不在某个位置停下。如果我们使用十位数字表示，$1/7$ 将被舍入为 $0.142857142$。如果我们使用十位数字计算 $1/7*7$，结果将是 $0.999999994$，并不是 $1$。此外，在十进制中能够用有穷数字表示的数字，在二进制中将是无穷数。例如，$12.7-20+7.3$用双精度数计算，结果不等于 $0$，因为 $12.7$ 和 $7.3$ 在二进制中都没有精确的有穷表示（详见练习2.3）。

在继续前进之前，切记：整数有精确表示并且没有舍入错误。

多数现代 CPU 浮点计算和整数计算一样快。不过，使用其它的数字类型（比如长整数或单精度数）编译 Lua 也很容易。对像类似嵌入式这样没有浮点数硬件支持的系统非常有用。详情参见发行版中的 \verb|luaconf.h| 文件。

可以书写带有可选小数部分及可选十进制指数部分的数字常量。有效数字示例如下：
\begin{verbatim}
        4       0.4     4.57e-3         0.3e12          5E+20
\end{verbatim}
还可以加上 $0x$ 前缀书写十六进制常量。从 Lua 5.2 开始，十六进制常量也可以有小数和指数（通过 `\verb|p|' 或 `\verb|P|' 前缀），示例如下：
\begin{verbatim}
        0xff (255)      0x1A3 (419)     0x0.2 (0.125)   0x1p-1 (0.5)
        0xa.bp2 (42.75)
\end{verbatim}
（每个常量后面的括号里是它的十进制表示）
